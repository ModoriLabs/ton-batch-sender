#include "imports/stdlib.fc";
#include "message.fc";
#include "op.fc";
#include "error.fc";
#include "gas.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
    return ();
  }

  slice cs = in_msg_full.begin_parse();

  int flags = cs~load_uint(4);
  if (flags & 1) {
    return ();
  }

  slice sender_address = cs~load_msg_addr();
  cs~load_msg_addr(); ;; skip dst
  cs~load_coins(); ;; skip value
  cs~skip_bits(1); ;; skip extracurrency collection
  cs~load_coins(); ;; skip ihr_fee
  int fwd_value = cs~load_coins(); ;; Fees for forwarding messages assigned by validators
  int fwd_fee = muldiv(fwd_value, 3, 2); ;; use message fwd_fee for estimation of forward_payload costs

  int op = in_msg_body~load_uint(32);
  in_msg_body~load_uint(64); ;; skip query_id

  if (op == op::transfer_notification) {
    (int jetton_amount, slice from) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr());
    cell forward_payload = in_msg_body~load_ref();
    slice forward_payload_slice = forward_payload.begin_parse();

    throw_unless(error::invalid_amount, jetton_amount > 0);
    int transferred_op = forward_payload_slice~load_uint(32);
    int query_id = forward_payload_slice~load_uint(64);

    if (transferred_op == op::send) {
      cell messages = forward_payload_slice~load_dict();
      int size = 0;
      int total_amount = 0;

      (int key, slice message, int flag) = messages.udict_get_min?(64);
      while (flag) {
        (slice to, int amount) = (message~load_msg_addr(), message~load_coins());
        size += 1;
        total_amount += amount;

        (key, message, flag) = messages.udict_get_next?(64, key);
      }

      throw_unless(error::invalid_amount, jetton_amount >= total_amount);
      throw_unless(error::invalid_message, size > 0);

      ;; TODO Check service fee

      ;; Note
      ;; Jetton Transfer Minimum Fee = 0.04TON
      ;; 0.04 = 0.015 * 2 + 0.01
      ;; * 0.015 is jetton transfer gas_consumption
      ;; * 0.01 is jetton wallet minimum storage fee
      ;; TODO : Hardcoded gas calculation is not good. It should be calculated by gas.fc
      int gas_required_per_transfer = 50000000; ;; 0.05TON
      int gas_required = gas_required_per_transfer * size;
      throw_unless(error::insufficient_gas, msg_value > gas_required);

      (key, message, flag) = messages.udict_get_min?(64);
      while (flag) {
        (slice to, int amount) = (message~load_msg_addr(), message~load_coins());

        var body = create_simple_transfer_body(query_id, 0, amount, to);
        ;; Ignore sender_address condition. It's not necessary to check it.
        ;; Why? If sender_address is not batch_sender's jetton wallet address, nothing will happen.
        send_simple_message(gas_required_per_transfer, sender_address, body.end_cell(), IGNORE_ERRORS);

        (key, message, flag) = messages.udict_get_next?(64, key);
      }

      ;; Send remaining gas to the sender
      send_raw_message(begin_cell()
        .store_uint(0x10, 6)
        .store_slice(from)
        .store_coins(msg_value - gas_required)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell(), IGNORE_ERRORS);
    }
  }
}
